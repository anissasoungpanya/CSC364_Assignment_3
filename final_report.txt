For this assignment, we were asked to simulate TCP-like behavior over UDP. We were asked to implement a client that divides a file into multiple chunks and sends them over UDP. This client then sends these chunks to a server, who validates integrity using checksums, and uses ACKs to acknowledge the packets. The client was asked to retransmit packets if an ACK is not received within its specified timeout, as well as be able to implement congestion control mechanisms. These mechanisms were slow start, congestion avoidance and fast retransmit.


Slow start mechanism entails beginning the TCP connection with a small congestion window size. This window size is then doubled for each acknowledgement received, and continues to do so until the slow start threshold (ssthresh) is reached, or packet loss is detected. In order to simulate this, I started with a small initial cwnd of 1 packet, and setting the initial ssthresh to 64 packets. I defined this as a ‘slow_start’ state. Then, I implemented a can_send_more function that counts the number of packets sent but not yet ACKed. If this count is less than our cwnd, then we can send more. Then, in my handle_ack function, if a new ACK is received, we check if we are still in our ‘slow_start’ state. From here, we add the number of packets ACKed to our cwnd, and if this cwnd is greater than our ssthresh we change the state (self.state) to ‘congestion_avoidance’. The program continues increasing the cwnd like this (exponentially) until the cwnd exceeds ssthresh. 


Congestion avoidance is reached once the cwnd exceeds the ssthresh, or a packet must be retransmitted. Once this happens, the cwnd is incemented by 1 (linearly), instead of exponentially.  If we reach a congestion avoidance state, I increase the cwnd to 1/cwnd per ACKed packet. More specifically, cwnd is set to 
cwnd += packets_acked / cwnd. This formula is implemented so that the cwnd is increased by 1 per RTT. 


Fast retransmit is a mechanism implemented by TCP when it receives consecutive duplicate ACKs for the same packet. This signals that the server is not receiving the packet, prompting the client to retransmit the specified packet. This is faster than regular transmission since it retransmits packets immediately, rather than waiting for a timeout.  In order to implement this, in my handle_ack function, I have an if-statement that checks if the received ACK number is the same as the last received ACK. If the numbers are the same, I increment a duplicate_ack_count by 1. I then check for when this count reaches 3. When this happens, this indicates 3 duplicate ACKs, indicating packet loss. From here, within the if-statement, I set the variable retransmit_seq to this duplicate ACK number, find the packet data for this ACK number and create a packet with the ACK number and its corresponding data. This packet is then sent to the server immediately. Next, I reduce the ssthresh by cutting it in half, and set the cwnd to this new ssthresh + 3. I also set the self.state to ‘congestion_avoidance’ since we have detected packet loss. Finally, I reset the duplicate_ack_count.


In order to handle timeouts, I first set my TIMEOUT variable to 500 ms. This timeout means that if no ACK is received within 500 ms, this packet is considered lost. I then implemented an unacked_packets dictionary, which holds entries of format seq_num: (packet_data, send_time, retransmit_count). Send_time refers to the timestamp when the packet was sent. When first sent, all packets are initially added to this dictionary, and are removed when their corresponding ACK number is received. I then implemented a check_timeouts function that gets the current time, iterates through the packets in the unacked_packets dictionary and calculates the elapsed time since each packet was sent. If this time elapses 500 ms, the packet is considered dropped and is added to the timed_out_packets list. 


When packets are timed out, they must be retransmitted. In the program, two types of retransmissions are implemented. The first is fast retransmit, explained above, which is triggered by 3 duplicate ACKs being received. The second type of retransmission is triggered by packets being timed out. In order to handle timed out packets, within the check_timeouts function, the timed_out_packets list is traversed through, and packets are created and sent with the corresponding ACK numbers and their data. For both types of retransmissions (timed out and fast retransmission), the retransmission count is incremented by 1, for the packet’s corresponding entry in the unacked_packets dictionary.  In addition, the ssthresh is set to half of the current cwnd, the cwnd is then reset to 1 (initial cwnd), and the self.state is set to ‘slow_start’. 


I then implemented the program with packet loss percentages of 1%, 10% and 50%. First, I graphed the Congestion Window vs. RTT Patterns. I found that in comparison, as the packet loss percentage increased, the cwnd values decreased. 1% packet loss experienced maximum cwnd values up to 15-25%, 10% packet loss experienced maximum cwnd values up to 10-12%, while 50% packet loss experienced maximum cwnd values up to 6-10%. I also noticed that as packet loss percentage increased, so did the number of resets due to timeouts. This growth happened linearly as well. Next, I graphed Retransmissions vs Time Patterns. Here, I found that as the packet loss percentage increased, so did the number of retransmissions. 1% packet loss had about 360 total retransmissions, 10% had about 360 as well, and 50% had over 2000 retransmissions.The graphs of all three percentages reflected fairly linear growth. From this, I found that with high packet loss, came more retransmissions, lower cwnd values, and longer transfer time (due to more retransmissions).


One of the challenges I faced was the server closing too early before the client finished retransmitting. In order to fix this, I increased the server’s completion timeout from 2 seconds to 30 seconds. I also faced a challenge when implementing my packet retransmissions. Inside of my handle_ack function, I call self.lock since the main thread and receiver thread both are accessing the same shared data (variables). This function ensures only one thread modifies this data at a time. Inside of this function, when attempting to retransmit packets, I called my send_packet function. However, self.lock is also called within send_packet, resulting in the function trying to acquire the lock that was called in handle_ack. This resulted in a deadlock. In order to fix this, rather than calling send_packet, I instead directly created and sent a packet with the corresponding ACK that needed to be retransmitted.From this assignment, I was able to learn how TCP is implemented in practice, rather than just in theory. In terms of congestion control, I learned that high packet loss limits cwnd growth, and requires more retransmissions. I also learned that when implementing ACKs, they require careful tracking.